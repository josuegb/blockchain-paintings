"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fabric_shim_1 = require("fabric-shim");
var fabric_chaincode_utils_1 = require("@theledger/fabric-chaincode-utils");
var convector_core_errors_1 = require("@worldsibu/convector-core-errors");
require("reflect-metadata");
var param_decorator_1 = require("./param.decorator");
var controller_decorator_1 = require("./controller.decorator");
var invokableMetadataKey = Symbol('invokable');
function Invokable() {
    return function (target, key, descriptor) {
        var fn = descriptor.value;
        if (typeof fn !== 'function') {
            throw new convector_core_errors_1.ControllerInvalidFunctionError();
        }
        var invokables = Reflect.getMetadata(invokableMetadataKey, target.constructor) || {};
        Reflect.defineMetadata(invokableMetadataKey, tslib_1.__assign({}, invokables, (_a = {}, _a[key] = true, _a)), target.constructor);
        // The use of `function` here is necessary to keep the context of `this`
        descriptor.value = function internalFn(stubHelper, args) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;
                var schemas, identity, namespace, ctx, e_1, error;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            schemas = Reflect.getOwnMetadata(param_decorator_1.paramMetadataKey, target, key);
                            if (!schemas) return [3 /*break*/, 2];
                            if (schemas.length !== args.length) {
                                throw new convector_core_errors_1.ControllerInvalidInvokeError(key, args.length, schemas.length);
                            }
                            return [4 /*yield*/, schemas.reduce(function (result, _a, index) {
                                    var schema = _a[0], opts = _a[1], model = _a[2];
                                    return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                        var paramResult, e_2;
                                        return tslib_1.__generator(this, function (_b) {
                                            switch (_b.label) {
                                                case 0:
                                                    _b.trys.push([0, 4, , 5]);
                                                    if (!opts.update) return [3 /*break*/, 1];
                                                    paramResult = schema.cast(args[index], opts);
                                                    return [3 /*break*/, 3];
                                                case 1: return [4 /*yield*/, schema.validate(args[index], opts)];
                                                case 2:
                                                    paramResult = _b.sent();
                                                    _b.label = 3;
                                                case 3: return [3 /*break*/, 5];
                                                case 4:
                                                    e_2 = _b.sent();
                                                    throw new convector_core_errors_1.ControllerInvalidArgumentError(e_2, index, args[index]);
                                                case 5:
                                                    if (model) {
                                                        try {
                                                            paramResult = new model(JSON.parse(args[index]));
                                                        }
                                                        catch (e) {
                                                            throw new convector_core_errors_1.ControllerArgumentParseError(e, index, args[index]);
                                                        }
                                                    }
                                                    return [4 /*yield*/, result];
                                                case 6: return [2 /*return*/, (_b.sent()).concat([paramResult])];
                                            }
                                        });
                                    });
                                }, Promise.resolve([]))];
                        case 1:
                            args = _a.sent();
                            _a.label = 2;
                        case 2:
                            identity = new fabric_shim_1.ClientIdentity(stubHelper.getStub());
                            namespace = Reflect.getMetadata(controller_decorator_1.controllerMetadataKey, target.constructor);
                            ctx = Object.create(this[namespace], { sender: { value: identity.getX509Certificate().fingerPrint } });
                            _a.label = 3;
                        case 3:
                            _a.trys.push([3, 5, , 6]);
                            return [4 /*yield*/, fn.call.apply(fn, [ctx].concat(args))];
                        case 4: return [2 /*return*/, _a.sent()];
                        case 5:
                            e_1 = _a.sent();
                            error = new fabric_chaincode_utils_1.ChaincodeError(e_1.message);
                            error.stack = e_1.stack;
                            throw error;
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        var _a;
    };
}
exports.Invokable = Invokable;
function getInvokables(controller) {
    var obj;
    var namespace;
    var invokables;
    try {
        namespace = Reflect.getMetadata(controller_decorator_1.controllerMetadataKey, controller);
    }
    catch (e) {
        throw new convector_core_errors_1.ControllerNamespaceMissingError(e, '');
    }
    try {
        obj = new controller();
    }
    catch (e) {
        throw new convector_core_errors_1.ControllerInstantiationError(e, namespace);
    }
    try {
        invokables = Reflect.getMetadata(invokableMetadataKey, controller);
        if (!invokables) {
            throw new TypeError();
        }
    }
    catch (e) {
        throw new convector_core_errors_1.ControllerInvokablesMissingError(e, namespace);
    }
    return Object.keys(invokables)
        .reduce(function (result, k) {
        return (tslib_1.__assign({}, result, (_a = {}, _a[namespace + "_" + k] = obj[k], _a)));
        var _a;
    }, (_a = {}, _a[namespace] = obj, _a));
    var _a;
}
exports.getInvokables = getInvokables;
//# sourceMappingURL=invokable.decorator.js.map